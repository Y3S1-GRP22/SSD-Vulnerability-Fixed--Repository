const router = require("express").Router();
const transactionSchema = require("../models/financeTransaction");
const incomeSchema = require("../models/income");
const expenseSchema = require("../models/expense");
const budgetSchema = require("../models/budget");
const { body, param } = require("express-validator");
const rateLimit = require("express-rate-limit");
const helmet = require("helmet");
const logger = require("../utils/logger");

router.use(helmet());

const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: "Too many requests from this IP, please try again later.",
});

router.use(apiLimiter);

//Read Transactions----------------------------------------------

router.get("/readfinanceT", async (req, res) => {
  try {
    const data = await transactionSchema.find({});
    logger.info("Fetched all transactions");
    res.status(200).json(data);
  } catch (error) {
    logger.error(`Error fetching transactions: ${error.message}`);
    res
      .status(500)
      .json({ status: "Error fetching transactions", error: error.message });
  }
});

//Delete Transactions----------------------------------------------------------------------------

router.delete(
  "/deleteT/:id",
  [param("id").trim().escape()],
  async (req, res) => {
    const id = req.params.id;

    try {
      const result = await transactionSchema.findByIdAndRemove(id).exec();
      if (!result) {
        logger.info("Transaction not found");
        return res.status(404).json("Transaction not found");
      }
      logger.info("Transaction deleted successfully");
      res.status(200).json("Transaction deleted successfully");
    } catch (error) {
      logger.error(`Error deleting transaction: ${error.message}`);
      res
        .status(500)
        .json({ status: "Error deleting transaction", error: error.message });
    }
  }
);

//Update Transactions----------------------------------------------------------------------------

router
  .route("/updateT/:id")
  .put(
    [
      param("id").trim().escape(),
      body("newtypeshow").trim().escape(),
      body("newcategoryshow").trim().escape(),
      body("newamountshow").trim().escape(),
      body("newremarkshow").trim().escape(),
      body("newdateshow").trim().escape(),
      body("newnameshow").trim().escape(),
    ],
    async (req, res) => {
      const id = req.params.id;

      const {
        newtypeshow,
        newcategoryshow,
        newamountshow,
        newremarkshow,
        newdateshow,
        newnameshow,
      } = req.body;

      if (!newtypeshow || !newcategoryshow || !newnameshow) {
        return res.status(400).send("Type, Category, and Name are required");
      }

      if (isNaN(newamountshow)) {
        return res.status(400).send("Amount must be a number");
      }

      if (newremarkshow && newremarkshow.length > 200) {
        return res.status(400).send("Remark can be up to 200 characters");
      }

      if (newdateshow && !Date.parse(newdateshow)) {
        return res.status(400).send("Invalid date format");
      }

      const updateTransaction = {
        type: newtypeshow,
        category: newcategoryshow,
        amount: newamountshow,
        remark: newremarkshow,
        date: newdateshow,
        name: newnameshow,
      };

      try {
        const update = await transactionSchema
          .findByIdAndUpdate({ _id: id }, updateTransaction)
          .exec();
        if (!update) {
          logger.info("Transaction not found");
          return res.status(404).json("Transaction not found");
        }
        logger.info("Transaction updated successfully");
        res.status(200).json("Transaction updated successfully");
      } catch (err) {
        logger.error(`Error updating transaction: ${err.message}`);
        res
          .status(500)
          .json({ status: "Internal server error", error: err.message });
      }
    }
  );

//Find Transaction By ID----------------------------------------------------------------------------

router.get(
  "/readTByID/:id",
  [param("id").trim().escape()],
  async (req, res) => {
    fetchid = req.params.id;

    try {
      const data = await transactionSchema.findById(fetchid);
      if (!data) {
        logger.info("Transaction not found");
        return res.status(404).json("Transaction not found");
      }
      logger.info("Transaction fetched successfully");
      res.status(200).json(data);
    } catch (error) {
      logger.error(`Error fetching transaction: ${error.message}`);
      res
        .status(500)
        .json({ status: "Error fetching transaction", error: error.message });
    }
  }
);

//Add Transaction ----------------------------------------------------------------------------

router
  .route("/insertT")
  .post(
    [
      body("name").trim().escape(),
      body("type").trim().escape(),
      body("category").trim().escape(),
      body("amount").trim().escape(),
      body("remark").trim().escape(),
      body("date").trim().escape(),
      body("did").trim().escape(),
    ],
    (req, res) => {
      const { name, type, category, amount, remark, date, did } = req.body;

      if (!name || !type || !category || !did) {
        return res
          .status(400)
          .send("Name, Type, Category, and Driver ID are required");
      }

      if (isNaN(amount)) {
        return res.status(400).send("Amount must be a number");
      }

      if (remark && remark.length > 200) {
        return res.status(400).send("Remark can be up to 200 characters");
      }

      if (date && !Date.parse(date)) {
        return res.status(400).send("Invalid date format");
      }

      var trans = new transactionSchema({
        name,
        type,
        category,
        amount,
        remark,
        date,
        did,
      });

      try {
        trans.save();
        logger.info("Transaction added successfully");
        res.status(201).json("Transaction added successfully");
      } catch (err) {
        logger.error(`Error adding transaction: ${err.message}`);
        res
          .status(500)
          .json({ status: "Error adding transaction", error: err.message });
      }
    }
  );

//Find Duplicate Transaction ----------------------------------------------------------------------------

router.get("/readDuplicate/:did", async (req, res) => {
  fetchid = req.params.did;
  try {
    const data = await transactionSchema.find({ did: fetchid });
    logger.info("Duplicate transactions fetched successfully");
    res.status(200).json(data);
  } catch (error) {
    logger.error(`Error fetching duplicate transactions: ${error.message}`);
    res
      .status(500)
      .json({
        status: "Error fetching duplicate transactions",
        error: error.message,
      });
  }
});

//Search Transaction ----------------------------------------------------------------------------

router.get("/search/:key", async (req, res) => {
  try {
    const result = await transactionSchema.find({
      $or: [
        {
          type: { $regex: req.params.key },
        },
        {
          name: { $regex: req.params.key },
        },
        {
          date: { $regex: req.params.key },
        },
        {
          category: { $regex: req.params.key },
        },
      ],
    });
    logger.info("Transactions search completed");
    res.status(200).json(result);
  } catch (error) {
    logger.error(`Error searching transactions: ${error.message}`);
    res
      .status(500)
      .json({ status: "Error searching transactions", error: error.message });
  }
});

//Insert Income ----------------------------------------------------------------------------

router.post(
  "/insertIncome",
  [
    body("amountI").trim().escape(),
    body("dateI").trim().escape(),
    body("didI").trim().escape(),
  ],
  async (req, res) => {
    const { amountI, dateI, didI } = req.body;

    if (isNaN(amountI)) {
      return res.status(400).send("Amount must be a number");
    }

    if (dateI && !Date.parse(dateI)) {
      return res.status(400).send("Invalid date format");
    }

    if (!didI) {
      return res.status(400).send("Driver ID is required");
    }

    var income = new incomeSchema({ amount: amountI, date: dateI, did: didI });

    try {
      await income.save();
      logger.info("Income added successfully");
      res.status(201).json("Income added successfully");
    } catch (err) {
      logger.error(`Error adding income: ${err.message}`);
      res
        .status(500)
        .json({ status: "Error adding income", error: err.message });
    }
  }
);

//Read Income----------------------------------------------

router.get("/readIncome", async (req, res) => {
  try {
    const data = await incomeSchema.find({});
    logger.info("Fetched all income records");
    res.status(200).json(data);
  } catch (error) {
    logger.error(`Error fetching income records: ${error.message}`);
    res
      .status(500)
      .json({ status: "Error fetching income records", error: error.message });
  }
});

//Insert Expense ----------------------------------------------------------------------------

router.post(
  "/insertExpense",
  [
    body("amountE").trim().escape(),
    body("dateE").trim().escape(),
    body("didE").trim().escape(),
  ],
  async (req, res) => {
    const { amountE, dateE, didE } = req.body;

    if (!amountE || !dateE) {
      return res.status(400).send("Amount, Date, and are required");
    }
    if (isNaN(amountE)) {
      return res.status(400).send("Amount must be a number");
    }

    if (dateE && !Date.parse(dateE)) {
      return res.status(400).send("Invalid date format");
    }

    if (!didE) {
      return res.status(400).send("Driver ID is required");
    }

    var expense = new expenseSchema({
      amount: amountE,
      date: dateE,
      did: didE,
    });

    try {
      await expense.save();
      logger.info("Expense added successfully");
      res.status(201).json("Expense added successfully");
    } catch (err) {
      logger.error(`Error adding expense: ${err.message}`);
      res
        .status(500)
        .json({ status: "Error adding expense", error: err.message });
    }
  }
);

//Read Expense----------------------------------------------

router.get("/readExpense", async (req, res) => {
  try {
    const data = await expenseSchema.find({});
    logger.info("Fetched all expense records");
    res.status(200).json(data);
  } catch (error) {
    logger.error(`Error fetching expense records: ${error.message}`);
    res
      .status(500)
      .json({ status: "Error fetching expense records", error: error.message });
  }
});

//Find Duplicate Income ----------------------------------------------------------------------------

router.get("/readDuplicateIncome/:did", async (req, res) => {
  fetchid = req.params.did;
  try {
    const data = await expenseSchema.find({ did: fetchid });
    logger.info("Duplicate expense records fetched successfully");
    res.status(200).json(data);
  } catch (error) {
    logger.error(`Error fetching duplicate expense records: ${error.message}`);
    res
      .status(500)
      .json({
        status: "Error fetching duplicate expense records",
        error: error.message,
      });
  }
});

//Find Duplicate Expense ----------------------------------------------------------------------------

router.get("/readDuplicateExpense/:did", async (req, res) => {
  fetchid = req.params.did;
  try {
    const data = await expenseSchema.find({ did: fetchid });
    logger.info("Duplicate expense records fetched successfully");
    res.status(200).json(data);
  } catch (error) {
    logger.error(`Error fetching duplicate expense records: ${error.message}`);
    res
      .status(500)
      .json({
        status: "Error fetching duplicate expense records",
        error: error.message,
      });
  }
});

//Read Type ----------------------------------------------------------------------------

router.get("/readType/:type", async (req, res) => {
  const fetchtype = req.params.type;

  try {
    const data = await transactionSchema.find({ type: fetchtype });
    logger.info("Transactions by type fetched successfully");
    res.status(200).json(data);
  } catch (error) {
    logger.error(`Error fetching transactions by type: ${error.message}`);
    res
      .status(500)
      .json({
        status: "Error fetching transactions by type",
        error: error.message,
      });
  }
});

//Read Budget ----------------------------------------------------------------------------

router.get("/readBudget", async (req, res) => {
  try {
    const data = await budgetSchema.find().sort({ _id: -1 }).limit(1);
    logger.info("Fetched latest budget");
    res.status(200).json(data);
  } catch (error) {
    logger.error(`Error fetching budget: ${error.message}`);
    res
      .status(500)
      .json({ status: "Error fetching budget", error: error.message });
  }
});

//Add Budget ----------------------------------------------------------------------------

router.post("/insertBudget", async (req, res) => {
  const { budget, dateBudget } = req.body;
  if (!budget || !dateBudget) {
    return res.status(400).send("Budget, date are required");
  }
  if (isNaN(budget)) {
    return res.status(400).send("Budget must be a number");
  }

  if (dateBudget && !Date.parse(dateBudget)) {
    return res.status(400).send("Invalid date format");
  }

  const Bdata = new budgetSchema({ budget: budget, date: dateBudget });

  try {
    await Bdata.save();
    logger.info("Budget added successfully");
    res.status(201).json("Budget added successfully");
  } catch (err) {
    logger.error(`Error adding budget: ${err.message}`);
    res.status(500).json({ status: "Error adding budget", error: err.message });
  }
});

module.exports = router;
